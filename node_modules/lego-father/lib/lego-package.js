'use strict';

var path = require('path');
var fs = require('fs');
var join = path.join;
var exists = fs.existsSync;
var util = require('./util');
var Package = require('./package');
var mixarg = require('mixarg');
var debug = require('debug')('father:lego');

var LegoPackage = Package.extend({

  readPackage: function() {
    if (!this.options.moduleDir) this.options.moduleDir = 'lego_modules';

    var pkgFile = normalize(join(this.dest, 'package.json'));
    debug('readPackage(%s) info %s', pkgFile.id, JSON.stringify(pkgFile));

    parseDeps(pkgFile, 'dependencies', this);

    // Only use the devDependencies of father package
    if (!this.father) {
      parseDeps(pkgFile, 'devDependencies', this);
      parseDeps(pkgFile, 'engines', this);
    } else {
      pkgFile.devDependencies = {};
      pkgFile.engines = {};
    }

    return pkgFile;
  }

});

module.exports = LegoPackage;

function normalize(pkg) {
  var dest = path.dirname(pkg);
  delete require.cache[require.resolve(pkg)];
  pkg = require(pkg);
  pkg.lego = pkg.lego || {};

  // detect main type
  if (!pkg.lego.main) {
    pkg.lego.main = 'index.js';
  }
  if (typeof pkg.lego.main !== 'string') {
    throw new Error('pkg.lego.main should be string.');
  }

  // handle ./index.js
  pkg.lego.main = pkg.lego.main.replace(/^\.\//, '');

  // handle index
  if (path.extname(pkg.lego.main) === '') {
    pkg.lego.main += '.js';
  }

  // detect output type
  if (!pkg.lego.output) {
    pkg.lego.output = [];
  }
  if (!Array.isArray(pkg.lego.output)) {
    throw new Error('pkg.lego.output should be array.');
  }

  var buildArgs = mixarg(pkg.lego.buildArgs);
  if (buildArgs.ignore) buildArgs.ignore = buildArgs.ignore.split(',');
  if (buildArgs.skip) buildArgs.skip = buildArgs.skip.split(',');
  pkg.lego.buildArgs = buildArgs;

  var ret = {
    id: pkg.name + '@' + pkg.version,
    name: pkg.name,
    version: pkg.version,
    dependencies: pkg.lego.dependencies || {},
    devDependencies: pkg.lego.devDependencies || {},
    engines: pkg.lego.engines || {},
    main: pkg.lego.main,
    dest: dest,
    output: pkg.lego.output,
    origin: pkg
  };

  return ret;
}

function parseDeps(pkgFile, prop, pkg) {
  var deps = pkgFile[prop];
  Object.keys(deps)
  .forEach(function(name) {
    deps[name] = resolveDeps(name, deps, pkg);
  });
}

function resolveDeps(name, deps, pkg) {
  var version, dest;
  var base = util.getBase(pkg);

  // detech current pkg and father pkg
  var levelCount = 2;
  while (levelCount-- && !version && pkg) {
    dest = join(pkg.dest, pkg.options.moduleDir, name);
    version = util.getVersion(deps[name], dest);
    pkg = pkg.father;
  }

  // detect root lego_modules
  if (!version && pkg) {
    dest = join(base, pkg.options.moduleDir, name);
    if (exists(dest)) {
      version = util.getVersion(deps[name], dest);
    }
  }

  if (!version) {
    throw new Error('no matched version of ' + name);
  }
  return {
    id: name + '@' + version.version,
    name: name,
    version: version.version,
    dest: join(dest, version.dir || version.version)
  };
}
